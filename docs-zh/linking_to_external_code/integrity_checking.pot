# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-11-19 16:18+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:2
msgid "## Integrity checking & lock files"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:4
msgid "### Introduction"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:13
msgid ""
"Let's say your module depends on remote module `https://some.url/a.ts`. When "
"you compile your module for the first time `a.ts` is retrieved, compiled and "
"cached.  It will remain this way until you run your module on a new machine "
"(say in production) or reload the cache (through `deno cache --reload` for "
"example). But what happens if the content in the remote url "
"`https://some.url/a.ts` is changed? This could lead to your production "
"module running with different dependency code than your local module. Deno's "
"solution to avoid this is to use integrity checking and lock files."
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:15
msgid "### Caching and lock files"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:22
msgid ""
"Deno can store and check subresource integrity for modules using a small "
"JSON file. Use the `--lock=lock.json` to enable and specify lock file "
"checking. To update or create a lock use `--lock=lock.json "
"--lock-write`. The `--lock=lock.json` tells Deno what the lock file to use "
"is, while the `--lock-write` is used to output dependency hashes to the lock "
"file (`--lock-write` must be used in conjunction with `--lock`)."
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:25
msgid ""
"A `lock.json` might look like this, storing a hash of the file against the "
"dependency:"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:34
#, no-wrap
msgid ""
"```json\n"
"{\n"
"  \"https://deno.land/std@$STD_VERSION/textproto/mod.ts\": "
"\"3118d7a42c03c242c5a49c2ad91c8396110e14acca1324e7aaefd31a999b71a4\",\n"
"  \"https://deno.land/std@$STD_VERSION/io/util.ts\": "
"\"ae133d310a0fdcf298cea7bc09a599c49acb616d34e148e263bcb02976f80dee\",\n"
"  \"https://deno.land/std@$STD_VERSION/async/delay.ts\": "
"\"35957d585a6e3dd87706858fb1d6b551cb278271b03f52c5a2cb70e65e00c26a\",\n"
"   ...\n"
"}\n"
"```\n"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:36
msgid "A typical workflow will look like this:"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:38
#, no-wrap
msgid "**src/deps.ts**\n"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:43
msgid ""
"```ts // Add a new dependency to \"src/deps.ts\", used somewhere else.  "
"export { xyz } from \"https://unpkg.com/xyz-lib@v0.9.0/lib.ts\"; ```"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:45
msgid "Then:"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:49
msgid ""
"```shell # Create/update the lock file \"lock.json\".  deno cache "
"--lock=lock.json --lock-write src/deps.ts"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:55
msgid ""
"# Include it when committing to source control.  git add -u lock.json git "
"commit -m \"feat: Add support for xyz using xyz-lib\" git push ```"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:57
msgid "Collaborator on another machine -- in a freshly cloned project tree:"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:62
msgid ""
"```shell # Download the project's dependencies into the machine's cache, "
"integrity # checking each resource.  deno cache --reload --lock=lock.json "
"src/deps.ts"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:66
msgid "# Done! You can proceed safely.  deno test --allow-read src ```"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:68
msgid "### Runtime verification"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:74
msgid ""
"Like caching above, you can also use the `--lock=lock.json` option during "
"use of the `deno run` sub command, validating the integrity of any locked "
"modules during the run. Remember that this only validates against "
"dependencies previously added to the `lock.json` file. New dependencies will "
"be cached but not validated."
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:77
msgid ""
"You can take this a step further as well by using the `--cached-only` flag "
"to require that remote dependencies are already cached."
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:81
msgid "```shell deno run --lock=lock.json --cached-only mod.ts ```"
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:84
msgid ""
"This will fail if there are any dependencies in the dependency tree for "
"mod.ts which are not yet cached."
msgstr ""

#. type: Plain text
#: docs/linking_to_external_code/integrity_checking.md:85
msgid "<!-- TODO - Add detail on dynamic imports -->"
msgstr ""
